---
phase: 03-react-agent-streaming
plan: 05
type: execute
wave: 4
depends_on: ["03-04"]
files_modified:
  - frontend/lib/entity-parser.ts
  - frontend/components/shared/EntityRenderer.tsx
  - frontend/app/flowtoken/page.tsx
autonomous: true

must_haves:
  truths:
    - "Frontend parses :::contact and :::event markers from streamed content"
    - "ContactCard renders when contact entity is parsed"
    - "CalendarEvent renders when event entity is parsed"
    - "Entities render correctly during active streaming"
  artifacts:
    - path: "frontend/lib/entity-parser.ts"
      provides: "Entity extraction from markdown"
      exports: ["parseEntities", "EntityType", "ParsedEntity"]
    - path: "frontend/components/shared/EntityRenderer.tsx"
      provides: "Component that renders parsed entities"
      exports: ["EntityRenderer"]
  key_links:
    - from: "frontend/lib/entity-parser.ts"
      to: "backend/agent/prompts.py"
      via: "matching marker syntax"
      pattern: ":::contact|:::event"
    - from: "frontend/components/shared/EntityRenderer.tsx"
      to: "frontend/components/ContactCard.tsx"
      via: "renders ContactCard for contact entities"
      pattern: "ContactCard"
    - from: "frontend/components/shared/EntityRenderer.tsx"
      to: "frontend/components/CalendarEvent.tsx"
      via: "renders CalendarEvent for event entities"
      pattern: "CalendarEvent"
---

<objective>
Create frontend entity parsing and rendering for Contact and CalendarEvent markers.

Purpose: The backend agent emits entities as markdown markers (:::contact, :::event). The frontend must parse these markers from the streaming content and render the appropriate UI components. This completes the end-to-end entity flow.

Output: Entity parser utility and EntityRenderer component integrated into FlowToken page
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-react-agent-streaming/03-CONTEXT.md
@.planning/phases/03-react-agent-streaming/03-RESEARCH.md
@frontend/types/index.ts
@frontend/components/ContactCard.tsx
@frontend/components/CalendarEvent.tsx
@frontend/components/shared/MessageBubble.tsx
@frontend/app/flowtoken/page.tsx
@backend/agent/prompts.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create entity parser utility</name>
  <files>frontend/lib/entity-parser.ts</files>
  <action>
Create `frontend/lib/entity-parser.ts`:

```typescript
/**
 * Entity parser for extracting Contact and CalendarEvent from markdown markers.
 *
 * The agent emits structured entities using markdown markers:
 * - :::contact\n```json\n{...}\n```\n::: for Contact cards
 * - :::event\n```json\n{...}\n```\n::: for CalendarEvent cards
 *
 * This parser extracts these markers and returns structured data
 * that EntityRenderer can display.
 */

import type { ContactCardProps, CalendarEventProps } from '@/types';

export type EntityType = 'contact' | 'event';

export interface ParsedContact {
  type: 'contact';
  data: ContactCardProps;
  raw: string;
  startIndex: number;
  endIndex: number;
}

export interface ParsedEvent {
  type: 'event';
  data: CalendarEventProps;
  raw: string;
  startIndex: number;
  endIndex: number;
}

export type ParsedEntity = ParsedContact | ParsedEvent;

export interface ParseResult {
  /** Text segments between entities */
  textSegments: string[];
  /** Parsed entities in order of appearance */
  entities: ParsedEntity[];
  /** Whether content has incomplete entity marker (still streaming) */
  hasIncompleteEntity: boolean;
}

// Regex patterns matching backend format
// Format: :::type\n```json\n{...}\n```\n:::
const CONTACT_PATTERN = /:::contact\s*\n```json\s*\n([\s\S]*?)\n```\s*\n:::/g;
const EVENT_PATTERN = /:::event\s*\n```json\s*\n([\s\S]*?)\n```\s*\n:::/g;

// Pattern to detect incomplete entity markers (still streaming)
const INCOMPLETE_PATTERN = /:::(?:contact|event)(?:\s*\n```json\s*\n[\s\S]*)?$/;

/**
 * Parse entities from markdown content.
 *
 * Extracts Contact and CalendarEvent entities from markdown markers,
 * returning both the entities and the remaining text segments.
 *
 * @param content - The markdown content to parse
 * @returns ParseResult with text segments, entities, and streaming status
 */
export function parseEntities(content: string): ParseResult {
  const entities: ParsedEntity[] = [];
  const allMatches: Array<{ match: RegExpExecArray; type: EntityType }> = [];

  // Find all contact matches
  let match: RegExpExecArray | null;
  const contactRegex = new RegExp(CONTACT_PATTERN.source, 'g');
  while ((match = contactRegex.exec(content)) !== null) {
    allMatches.push({ match, type: 'contact' });
  }

  // Find all event matches
  const eventRegex = new RegExp(EVENT_PATTERN.source, 'g');
  while ((match = eventRegex.exec(content)) !== null) {
    allMatches.push({ match, type: 'event' });
  }

  // Sort by position in content
  allMatches.sort((a, b) => a.match.index - b.match.index);

  // Parse each match
  for (const { match, type } of allMatches) {
    try {
      const jsonStr = match[1].trim();
      const data = JSON.parse(jsonStr);

      if (type === 'contact') {
        // Validate required field
        if (typeof data.name !== 'string') {
          console.warn('Contact missing required name field:', jsonStr.slice(0, 50));
          continue;
        }
        entities.push({
          type: 'contact',
          data: data as ContactCardProps,
          raw: match[0],
          startIndex: match.index,
          endIndex: match.index + match[0].length,
        });
      } else if (type === 'event') {
        // Validate required fields
        if (typeof data.title !== 'string' || typeof data.date !== 'string') {
          console.warn('Event missing required fields:', jsonStr.slice(0, 50));
          continue;
        }
        entities.push({
          type: 'event',
          data: data as CalendarEventProps,
          raw: match[0],
          startIndex: match.index,
          endIndex: match.index + match[0].length,
        });
      }
    } catch (e) {
      console.warn(`Failed to parse ${type} JSON:`, e);
      continue;
    }
  }

  // Build text segments (content between entities)
  const textSegments: string[] = [];
  let lastEnd = 0;

  for (const entity of entities) {
    // Text before this entity
    if (entity.startIndex > lastEnd) {
      textSegments.push(content.slice(lastEnd, entity.startIndex));
    }
    lastEnd = entity.endIndex;
  }

  // Text after last entity
  if (lastEnd < content.length) {
    const remaining = content.slice(lastEnd);
    // Check if remaining has incomplete entity marker
    const hasIncomplete = INCOMPLETE_PATTERN.test(remaining);
    if (hasIncomplete) {
      // Don't include incomplete marker in text segments
      const incompleteMatch = remaining.match(INCOMPLETE_PATTERN);
      if (incompleteMatch && incompleteMatch.index !== undefined) {
        textSegments.push(remaining.slice(0, incompleteMatch.index));
      }
    } else {
      textSegments.push(remaining);
    }
  }

  return {
    textSegments,
    entities,
    hasIncompleteEntity: INCOMPLETE_PATTERN.test(content.slice(lastEnd)),
  };
}

/**
 * Check if content contains any entity markers (complete or incomplete).
 */
export function hasEntityMarkers(content: string): boolean {
  return content.includes(':::contact') || content.includes(':::event');
}
```
  </action>
  <verify>
```bash
cd frontend && npm run lint -- lib/entity-parser.ts --fix
```
No lint errors.
  </verify>
  <done>
Entity parser extracts contacts and events from markdown markers, handles incomplete markers during streaming.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create EntityRenderer component</name>
  <files>frontend/components/shared/EntityRenderer.tsx</files>
  <action>
Create `frontend/components/shared/EntityRenderer.tsx`:

```typescript
'use client';

/**
 * EntityRenderer - Renders parsed entities inline with text.
 *
 * Takes parsed content (text segments + entities) and renders
 * them in order, using ContactCard and CalendarEvent components
 * for entities.
 */

import React from 'react';
import { ContactCard } from '@/components/ContactCard';
import { CalendarEvent } from '@/components/CalendarEvent';
import type { ParseResult, ParsedEntity } from '@/lib/entity-parser';

interface EntityRendererProps {
  /** Parse result from parseEntities() */
  parseResult: ParseResult;
  /** Whether content is actively streaming */
  isStreaming?: boolean;
  /** Render function for text segments (allows custom markdown rendering) */
  renderText?: (text: string, index: number) => React.ReactNode;
}

/**
 * Render a single entity as its corresponding component.
 */
function renderEntity(entity: ParsedEntity, index: number): React.ReactNode {
  if (entity.type === 'contact') {
    return (
      <div key={`entity-${index}`} className="my-3">
        <ContactCard {...entity.data} />
      </div>
    );
  }

  if (entity.type === 'event') {
    return (
      <div key={`entity-${index}`} className="my-3">
        <CalendarEvent {...entity.data} />
      </div>
    );
  }

  return null;
}

/**
 * Default text renderer - just returns the text as-is.
 * Override with custom markdown renderer if needed.
 */
function defaultRenderText(text: string, index: number): React.ReactNode {
  // Preserve whitespace and newlines
  return (
    <span key={`text-${index}`} className="whitespace-pre-wrap">
      {text}
    </span>
  );
}

export function EntityRenderer({
  parseResult,
  isStreaming = false,
  renderText = defaultRenderText,
}: EntityRendererProps): React.ReactElement {
  const { textSegments, entities, hasIncompleteEntity } = parseResult;

  // Interleave text segments and entities
  const elements: React.ReactNode[] = [];
  let entityIndex = 0;
  let textIndex = 0;

  // Build output by position
  // Text segments and entities alternate, starting with text before first entity
  for (let i = 0; i < textSegments.length + entities.length; i++) {
    if (i % 2 === 0 || entities.length === 0) {
      // Even indices: text segment
      if (textIndex < textSegments.length) {
        const text = textSegments[textIndex];
        if (text.trim()) {
          elements.push(renderText(text, textIndex));
        }
        textIndex++;
      }
    } else {
      // Odd indices: entity
      if (entityIndex < entities.length) {
        elements.push(renderEntity(entities[entityIndex], entityIndex));
        entityIndex++;
      }
    }
  }

  // Handle remaining items if counts don't match perfectly
  while (textIndex < textSegments.length) {
    const text = textSegments[textIndex];
    if (text.trim()) {
      elements.push(renderText(text, textIndex));
    }
    textIndex++;
  }

  while (entityIndex < entities.length) {
    elements.push(renderEntity(entities[entityIndex], entityIndex));
    entityIndex++;
  }

  return (
    <div className="entity-renderer">
      {elements}
      {isStreaming && hasIncompleteEntity && (
        <span className="inline-block animate-pulse text-gray-400 ml-1">
          ...
        </span>
      )}
    </div>
  );
}
```
  </action>
  <verify>
```bash
cd frontend && npm run lint -- components/shared/EntityRenderer.tsx --fix
```
No lint errors.
  </verify>
  <done>
EntityRenderer displays parsed entities inline with text using ContactCard and CalendarEvent components.
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate entity rendering into FlowToken page</name>
  <files>frontend/app/flowtoken/page.tsx</files>
  <action>
Update `frontend/app/flowtoken/page.tsx` to:
1. Import parseEntities and EntityRenderer
2. Point to backend API (localhost:8000) instead of local mock
3. Parse and render entities in assistant messages

Key changes:
- Change transport API to `http://localhost:8000/api/chat`
- Import entity parser and renderer
- Use EntityRenderer for assistant messages that contain entity markers
- Fall back to FlowTokenRenderer for messages without entities

```typescript
'use client';

import { useState, useCallback, useMemo, useRef, useEffect } from 'react';
import type { FormEvent, ChangeEvent, ReactElement } from 'react';

import { useChat } from '@ai-sdk/react';
import { DefaultChatTransport } from 'ai';

import { FlowTokenRenderer } from '@/components/flowtoken/FlowTokenRenderer';
import { Header } from '@/components/shared/Header';
import { MessageBubble } from '@/components/shared/MessageBubble';
import { ChatInput } from '@/components/shared/ChatInput';
import { TypingIndicator } from '@/components/shared/TypingIndicator';
import { EntityRenderer } from '@/components/shared/EntityRenderer';
import { parseEntities, hasEntityMarkers } from '@/lib/entity-parser';

export default function FlowTokenPage(): ReactElement {
  const [input, setInput] = useState('');

  // Point to backend agent API
  const transport = useMemo(
    () =>
      new DefaultChatTransport({
        api: 'http://localhost:8000/api/chat',
      }),
    []
  );

  const { messages, sendMessage, status, error } = useChat({
    transport,
    onError: (err) => {
      console.error('[FlowToken] useChat onError:', err);
    },
  });

  const isLoading = status === 'submitted' || status === 'streaming';

  const handleInputChange = useCallback(
    (e: ChangeEvent<HTMLInputElement>) => {
      setInput(e.target.value);
    },
    []
  );

  const handleSubmit = useCallback(
    async (e: FormEvent) => {
      e.preventDefault();
      if (!input.trim() || isLoading) return;

      const message = input;
      setInput('');
      await sendMessage({ text: message });
    },
    [input, isLoading, sendMessage]
  );

  const handlePresetSelect = useCallback(
    async (message: string) => {
      if (isLoading) return;
      await sendMessage({ text: message });
    },
    [isLoading, sendMessage]
  );

  // Transform messages with entity parsing
  const formattedMessages = useMemo(() => {
    const filtered = messages.filter(
      (m): m is typeof m & { role: 'user' | 'assistant' } =>
        m.role === 'user' || m.role === 'assistant'
    );

    return filtered.map((m, index, arr) => {
      const content = (m.parts ?? [])
        .filter((p): p is { type: 'text'; text: string } => p.type === 'text')
        .map((p) => p.text)
        .join('');

      const isStreaming =
        m.role === 'assistant' &&
        index === arr.length - 1 &&
        status === 'streaming';

      // Parse entities for assistant messages
      const parseResult = m.role === 'assistant' ? parseEntities(content) : null;
      const hasEntities = m.role === 'assistant' && hasEntityMarkers(content);

      return {
        id: m.id,
        role: m.role,
        content,
        isStreaming,
        parseResult,
        hasEntities,
      };
    });
  }, [messages, status]);

  // Scroll management
  const containerRef = useRef<HTMLDivElement>(null);
  const bottomRef = useRef<HTMLDivElement>(null);
  const [userHasScrolled, setUserHasScrolled] = useState(false);

  const handleScroll = useCallback(() => {
    const container = containerRef.current;
    if (!container) return;

    const isAtBottom =
      container.scrollHeight - container.scrollTop - container.clientHeight < 50;
    setUserHasScrolled(!isAtBottom);
  }, []);

  useEffect(() => {
    if (!userHasScrolled && bottomRef.current && bottomRef.current.scrollIntoView) {
      bottomRef.current.scrollIntoView({ behavior: 'smooth' });
    }
  }, [formattedMessages, userHasScrolled]);

  return (
    <div className="flex flex-col h-screen">
      <Header />
      <main className="flex-1 overflow-hidden bg-gray-50 pt-14">
        <div className="h-full max-w-3xl mx-auto flex flex-col">
          <div
            ref={containerRef}
            role="log"
            aria-live="polite"
            aria-label="Chat messages"
            onScroll={handleScroll}
            className="flex-1 overflow-y-auto flex flex-col gap-3 p-4"
          >
            {formattedMessages.map((m) => (
              <MessageBubble
                key={m.id}
                role={m.role}
                content={m.content}
                isStreaming={m.isStreaming}
                rawContent={m.role === 'assistant' ? m.content : undefined}
              >
                {m.role === 'assistant' ? (
                  m.hasEntities && m.parseResult ? (
                    <EntityRenderer
                      parseResult={m.parseResult}
                      isStreaming={m.isStreaming}
                      renderText={(text, idx) => (
                        <FlowTokenRenderer
                          key={`text-${idx}`}
                          content={text}
                          isStreaming={m.isStreaming}
                        />
                      )}
                    />
                  ) : (
                    <FlowTokenRenderer
                      content={m.content}
                      isStreaming={m.isStreaming}
                    />
                  )
                ) : undefined}
              </MessageBubble>
            ))}
            <div ref={bottomRef} />
          </div>
          {error && (
            <div
              role="alert"
              className="mx-4 mb-2 p-3 text-sm text-red-700 bg-red-50 border border-red-200 rounded-lg"
            >
              {error.message || 'An error occurred while streaming the response.'}
            </div>
          )}
          {isLoading && <TypingIndicator isVisible />}
          <ChatInput
            value={input}
            onChange={handleInputChange}
            onSubmit={handleSubmit}
            isLoading={isLoading}
            onPresetSelect={handlePresetSelect}
          />
        </div>
      </main>
    </div>
  );
}
```
  </action>
  <verify>
```bash
cd frontend && npm run lint -- app/flowtoken/page.tsx --fix && npm run build
```
No lint errors, build succeeds.
  </verify>
  <done>
FlowToken page connects to backend agent API and renders entities using EntityRenderer.
  </done>
</task>

</tasks>

<verification>
From frontend/ directory:

```bash
cd frontend
npm run lint
npm run build
```

Both pass without errors. Entity parser and renderer are integrated.
</verification>

<success_criteria>
- frontend/lib/entity-parser.ts exports parseEntities, hasEntityMarkers
- Parser regex matches backend prompt format (:::contact, :::event)
- EntityRenderer component renders ContactCard and CalendarEvent
- FlowToken page points to http://localhost:8000/api/chat
- Assistant messages with entities render using EntityRenderer
- Messages without entities fall back to FlowTokenRenderer
- Build succeeds with no TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-react-agent-streaming/03-05-SUMMARY.md`
</output>
