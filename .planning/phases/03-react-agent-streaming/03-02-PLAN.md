---
phase: 03-react-agent-streaming
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/streaming/__init__.py
  - backend/streaming/sse.py
  - backend/streaming/entity_parser.py
  - backend/agent/prompts.py
autonomous: true

must_haves:
  truths:
    - "SSE formatter emits AI SDK v6 compatible events"
    - "Entity parser extracts Contact and CalendarEvent from markdown"
    - "System prompt defines entity marker syntax"
  artifacts:
    - path: "backend/streaming/sse.py"
      provides: "SSE event formatting for AI SDK v6"
      exports: ["format_text_delta", "format_reasoning_delta", "format_done", "SSE_HEADERS"]
    - path: "backend/streaming/entity_parser.py"
      provides: "Entity extraction from markdown markers"
      exports: ["extract_entities", "EntityType"]
    - path: "backend/agent/prompts.py"
      provides: "System prompt with entity formatting"
      exports: ["AGENT_SYSTEM_PROMPT", "get_agent_prompt"]
  key_links:
    - from: "backend/streaming/sse.py"
      to: "AI SDK v6"
      via: "x-vercel-ai-ui-message-stream: v1 header"
      pattern: "x-vercel-ai-ui-message-stream"
    - from: "backend/agent/prompts.py"
      to: "backend/streaming/entity_parser.py"
      via: "matching entity marker syntax"
      pattern: ":::contact|:::event"
---

<objective>
Create SSE streaming utilities and entity handling for AI SDK v6 compatibility.

Purpose: The streaming module bridges LangGraph's token stream to the AI SDK's expected SSE protocol. The entity parser extracts structured Contact/CalendarEvent data from markdown markers. The system prompt tells the agent how to format entities.

Output: `backend/streaming/` module + `backend/agent/prompts.py`
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-react-agent-streaming/03-CONTEXT.md
@.planning/phases/03-react-agent-streaming/03-RESEARCH.md
@frontend/types/index.ts
@frontend/app/api/chat/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SSE formatting utilities</name>
  <files>backend/streaming/__init__.py, backend/streaming/sse.py</files>
  <action>
Create `backend/streaming/__init__.py`:
```python
from .sse import format_text_delta, format_reasoning_delta, format_done, SSE_HEADERS
from .entity_parser import extract_entities, EntityType

__all__ = [
    "format_text_delta",
    "format_reasoning_delta",
    "format_done",
    "SSE_HEADERS",
    "extract_entities",
    "EntityType",
]
```

Create `backend/streaming/sse.py`:
```python
"""SSE formatting utilities for AI SDK v6 compatibility.

The AI SDK v6 uses a specific SSE protocol with event types:
- text-delta: streaming text content
- reasoning-delta: agent reasoning (thoughts)
- [DONE]: signals stream completion

CRITICAL: The x-vercel-ai-ui-message-stream: v1 header is REQUIRED
for AI SDK's useChat hook to properly parse the stream.
"""
import json
from typing import Literal

# Required headers for AI SDK v6 SSE compatibility
SSE_HEADERS = {
    "x-vercel-ai-ui-message-stream": "v1",  # REQUIRED - AI SDK stream protocol
    "Content-Type": "text/event-stream",
    "Cache-Control": "no-cache",
    "Connection": "keep-alive",
}


def format_text_delta(content: str, message_id: str) -> str:
    """Format a text content chunk as SSE event.

    Args:
        content: The text content to stream
        message_id: Unique identifier for the message

    Returns:
        SSE formatted string: data: {...}\n\n
    """
    event = {
        "type": "text-delta",
        "id": message_id,
        "delta": content,
    }
    return f"data: {json.dumps(event)}\n\n"


def format_reasoning_delta(content: str, message_id: str) -> str:
    """Format agent reasoning (thoughts) as SSE event.

    Reasoning appears in a separate visual block from response text.
    Used for Thought-Action-Observation visibility.

    Args:
        content: The reasoning content
        message_id: Unique identifier for the message

    Returns:
        SSE formatted string for reasoning
    """
    event = {
        "type": "reasoning-delta",
        "id": message_id,
        "delta": content,
    }
    return f"data: {json.dumps(event)}\n\n"


def format_done() -> str:
    """Format stream completion signal.

    Returns:
        SSE formatted [DONE] marker
    """
    return "data: [DONE]\n\n"


def format_error(message: str, message_id: str) -> str:
    """Format an error as text-delta (so user sees it).

    We emit errors as text because the stream has already started
    (HTTP 200 sent) and we can't change status codes mid-stream.

    Args:
        message: User-friendly error message
        message_id: Message identifier

    Returns:
        SSE formatted error as text
    """
    return format_text_delta(f"\n\n*Error: {message}*", message_id)
```
  </action>
  <verify>
```python
python -c "
from streaming.sse import format_text_delta, format_done, SSE_HEADERS
print(format_text_delta('hello', 'msg-1'))
print(format_done())
print('Header:', SSE_HEADERS.get('x-vercel-ai-ui-message-stream'))
"
```
Should show properly formatted SSE events and v1 header.
  </verify>
  <done>
SSE formatting utilities exist with AI SDK v6 compatible event format and required headers.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create entity parser for markdown markers</name>
  <files>backend/streaming/entity_parser.py</files>
  <action>
Create `backend/streaming/entity_parser.py`:

```python
"""Entity extraction from markdown markers.

The agent emits structured entities using markdown markers:
- :::contact ... ::: for Contact cards
- :::event ... ::: for CalendarEvent cards

Entities are embedded in JSON code blocks within the markers.
This parser extracts and validates them against the frontend schemas.
"""
import json
import re
import logging
from typing import Literal, TypedDict, Optional
from enum import Enum

logger = logging.getLogger(__name__)


class EntityType(str, Enum):
    CONTACT = "contact"
    EVENT = "event"


class ContactEntity(TypedDict, total=False):
    """Matches frontend ContactCardProps interface."""
    name: str  # required
    email: Optional[str]
    phone: Optional[str]
    address: Optional[str]
    avatar: Optional[str]


class CalendarEventEntity(TypedDict, total=False):
    """Matches frontend CalendarEventProps interface."""
    title: str  # required
    date: str   # required
    startTime: Optional[str]
    endTime: Optional[str]
    location: Optional[str]
    description: Optional[str]


class ExtractedEntity(TypedDict):
    """Extracted entity with type and data."""
    type: EntityType
    data: ContactEntity | CalendarEventEntity
    raw: str  # Original marker text for replacement


# Regex patterns for entity markers
# Format: :::type\n```json\n{...}\n```\n:::
CONTACT_PATTERN = re.compile(
    r':::contact\s*\n```json\s*\n(.*?)\n```\s*\n:::',
    re.DOTALL
)
EVENT_PATTERN = re.compile(
    r':::event\s*\n```json\s*\n(.*?)\n```\s*\n:::',
    re.DOTALL
)


def extract_entities(markdown: str) -> list[ExtractedEntity]:
    """Extract all entities from markdown content.

    Args:
        markdown: The markdown content to parse

    Returns:
        List of extracted entities with type, data, and raw marker text
    """
    entities = []

    # Extract contacts
    for match in CONTACT_PATTERN.finditer(markdown):
        try:
            json_str = match.group(1).strip()
            data = json.loads(json_str)

            # Validate required field
            if "name" not in data:
                logger.warning(f"Contact missing required 'name' field: {json_str[:50]}")
                continue

            entities.append({
                "type": EntityType.CONTACT,
                "data": data,
                "raw": match.group(0),
            })
        except json.JSONDecodeError as e:
            logger.warning(f"Failed to parse contact JSON: {e}")
            continue

    # Extract events
    for match in EVENT_PATTERN.finditer(markdown):
        try:
            json_str = match.group(1).strip()
            data = json.loads(json_str)

            # Validate required fields
            if "title" not in data or "date" not in data:
                logger.warning(f"Event missing required fields: {json_str[:50]}")
                continue

            entities.append({
                "type": EntityType.EVENT,
                "data": data,
                "raw": match.group(0),
            })
        except json.JSONDecodeError as e:
            logger.warning(f"Failed to parse event JSON: {e}")
            continue

    return entities


def validate_contact(data: dict) -> bool:
    """Validate contact data against ContactCardProps schema."""
    if not isinstance(data.get("name"), str):
        return False
    # Optional fields can be missing or string
    for field in ["email", "phone", "address", "avatar"]:
        if field in data and not isinstance(data[field], str):
            return False
    return True


def validate_event(data: dict) -> bool:
    """Validate event data against CalendarEventProps schema."""
    if not isinstance(data.get("title"), str):
        return False
    if not isinstance(data.get("date"), str):
        return False
    # Optional fields
    for field in ["startTime", "endTime", "location", "description"]:
        if field in data and not isinstance(data[field], str):
            return False
    return True
```
  </action>
  <verify>
```python
python -c "
from streaming.entity_parser import extract_entities, EntityType
test = '''Here is a contact:
:::contact
\`\`\`json
{\"name\": \"John Doe\", \"email\": \"john@berlin.de\"}
\`\`\`
:::
'''
entities = extract_entities(test)
print(f'Found {len(entities)} entities')
print(f'Type: {entities[0][\"type\"]}, Name: {entities[0][\"data\"][\"name\"]}')
"
```
Should show 1 entity with contact type and name.
  </verify>
  <done>
Entity parser extracts Contact and CalendarEvent entities from markdown markers with validation.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create agent system prompt with entity formatting</name>
  <files>backend/agent/prompts.py</files>
  <action>
Create `backend/agent/prompts.py`:

```python
"""System prompts for the ReAct agent.

The prompt instructs the agent on:
1. When to use the knowledge base tool
2. How to format Contact and CalendarEvent entities
3. Tone and error handling behavior
"""
from langchain_core.prompts import ChatPromptTemplate

AGENT_SYSTEM_PROMPT = """You are a helpful assistant for Berlin city information.

You have access to a knowledge base tool that contains:
- Contact information for city employees and departments
- Upcoming events and city calendar
- General city services and information

## When to use the knowledge base

Use the search_knowledge_base tool when the user asks about:
- Specific people's contact details (emails, phone numbers, addresses)
- Department or agency information
- Events, festivals, or calendar information
- City services, facilities, or procedures

Do NOT use the tool for:
- General greetings or small talk ("Hi", "How are you?")
- Questions about yourself or your capabilities
- Math calculations or reasoning tasks
- Topics unrelated to Berlin city

## How to present information

### Contacts
When providing contact information, format EACH contact as:

:::contact
```json
{"name": "Full Name", "email": "email@berlin.de", "phone": "+49 30 ...", "address": "Street Address"}
```
:::

Include only fields that have data. Omit missing fields entirely (don't use null or empty strings).
Show TOP 3 most relevant contacts. If more exist, mention: "...and X more contacts available."

### Events
When providing event information, format EACH event as:

:::event
```json
{"title": "Event Name", "date": "2026-01-25", "startTime": "14:00", "endTime": "16:00", "location": "Venue Address", "description": "Brief description"}
```
:::

Include only fields that have data. Date is required, times and location are optional.
Show TOP 3 upcoming/relevant events. If more exist, mention: "...and X more events found."

### Mixing entities
You can freely mix contacts and events in a single response when relevant.
Add brief context before and after entities to make the response conversational.

## Tone and style

- Be concise and helpful
- Use brief reasoning: "Looking up Parks department contacts..." not lengthy explanations
- Admit when you don't know: "I couldn't find specific information about that. Try asking about city contacts, events, or services."
- If the knowledge base fails: "I'm having trouble accessing the knowledge base right now. Please try again."

## Error handling

- If no results: Suggest related topics they could ask about
- If partial data: Show what's available, note what's missing
- Never make up information not from the knowledge base
"""


def get_agent_prompt() -> ChatPromptTemplate:
    """Get the agent prompt template.

    Returns ChatPromptTemplate with system message and placeholder for messages.
    """
    return ChatPromptTemplate.from_messages([
        ("system", AGENT_SYSTEM_PROMPT),
        ("placeholder", "{messages}"),
    ])
```
  </action>
  <verify>
```python
python -c "
from agent.prompts import AGENT_SYSTEM_PROMPT, get_agent_prompt
print('Prompt length:', len(AGENT_SYSTEM_PROMPT))
print('Has contact marker:', ':::contact' in AGENT_SYSTEM_PROMPT)
print('Has event marker:', ':::event' in AGENT_SYSTEM_PROMPT)
prompt = get_agent_prompt()
print('Template messages:', len(prompt.messages))
"
```
Should show prompt with markers and 2 template messages.
  </verify>
  <done>
System prompt instructs agent on entity marker format matching the parser patterns.
  </done>
</task>

</tasks>

<verification>
From backend/ directory:

```bash
cd backend && source venv/bin/activate
python -c "
from streaming import format_text_delta, SSE_HEADERS, extract_entities
from agent.prompts import AGENT_SYSTEM_PROMPT

# Test SSE format
sse = format_text_delta('test', 'msg-1')
assert 'text-delta' in sse
print('SSE format: OK')

# Test header
assert SSE_HEADERS['x-vercel-ai-ui-message-stream'] == 'v1'
print('AI SDK header: OK')

# Test entity parsing
test_md = ''':::contact
\`\`\`json
{\"name\": \"Test User\", \"email\": \"test@berlin.de\"}
\`\`\`
:::'''
entities = extract_entities(test_md)
assert len(entities) == 1
assert entities[0]['data']['name'] == 'Test User'
print('Entity parsing: OK')

# Test prompt markers match parser
assert ':::contact' in AGENT_SYSTEM_PROMPT
assert ':::event' in AGENT_SYSTEM_PROMPT
print('Prompt-parser sync: OK')
"
```

All assertions pass.
</verification>

<success_criteria>
- backend/streaming/ module exists with sse.py and entity_parser.py
- SSE formatter emits events with correct AI SDK v6 format (text-delta, reasoning-delta)
- SSE_HEADERS includes x-vercel-ai-ui-message-stream: v1
- Entity parser extracts contacts and events from markdown markers
- System prompt defines matching entity marker syntax (:::contact, :::event)
- Prompt and parser use identical marker patterns
</success_criteria>

<output>
After completion, create `.planning/phases/03-react-agent-streaming/03-02-SUMMARY.md`
</output>
