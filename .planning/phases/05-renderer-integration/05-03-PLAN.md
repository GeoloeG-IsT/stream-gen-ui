---
phase: 05-renderer-integration
plan: 03
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - frontend/app/streamdown/page.tsx
  - frontend/components/streamdown/StreamdownRenderer.tsx
autonomous: true

must_haves:
  truths:
    - "Streamdown page streams real responses from backend (not mock data)"
    - "No incomplete XML tags visible during streaming"
    - "User can stop streaming with stop button"
    - "Errors show toast notification"
    - "Stream aborted on page navigation"
  artifacts:
    - path: "frontend/app/streamdown/page.tsx"
      provides: "Streamdown page with backend integration"
      contains: "marker=xml"
    - path: "frontend/components/streamdown/StreamdownRenderer.tsx"
      provides: "Renderer with skeleton support for incomplete tags"
      contains: "ComponentSkeleton"
  key_links:
    - from: "frontend/app/streamdown/page.tsx"
      to: "/api/chat?marker=xml"
      via: "DefaultChatTransport"
      pattern: "marker=xml"
    - from: "frontend/app/streamdown/page.tsx"
      to: "sonner"
      via: "toast.error"
      pattern: "toast\\.error"
---

<objective>
Wire Streamdown page to live backend with marker=xml, add stop button, error toast, and skeleton loading for incomplete XML tags.

Purpose: Completes WIRE-02 (Streamdown backend wiring) and UX-02 (transient markup hiding). The page currently uses mock `/api/chat?format=streamdown` - needs to switch to real backend with proper UX.

Output: Streamdown page fully integrated with backend, no visible incomplete XML tags during streaming.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-renderer-integration/05-CONTEXT.md
@.planning/phases/05-renderer-integration/05-RESEARCH.md

# Reference existing patterns
@frontend/app/flowtoken/page.tsx
@frontend/app/streamdown/page.tsx
@frontend/components/streamdown/StreamdownRenderer.tsx
@frontend/components/shared/StopButton.tsx
@frontend/components/shared/ComponentSkeleton.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire Streamdown page to backend with stop/error handling</name>
  <files>frontend/app/streamdown/page.tsx</files>
  <action>
Update streamdown/page.tsx following the FlowToken page pattern:

1. Change transport URL from mock to backend:
   - Add `const backendUrl = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://188.245.108.179:8000';`
   - Change transport api from `/api/chat?format=streamdown` to `${backendUrl}/api/chat?marker=xml`

2. Add stop function and error handling:
   - Destructure `stop` from useChat
   - Add `import { toast } from 'sonner';`
   - Update onError to show toast:
     ```typescript
     onError: (err) => {
       console.error('[Streamdown] useChat onError:', err);
       const message = err.message.includes('fetch')
         ? 'Network error - check your connection'
         : err.message.includes('500')
         ? 'Server error - please try again'
         : 'An error occurred';
       toast.error(message);
     },
     ```

3. Add abort on unmount:
   ```typescript
   // Abort stream on unmount (prevents background streaming)
   useEffect(() => {
     return () => {
       stop();
     };
   }, [stop]);
   ```

4. Add StopButton to UI:
   - Import `StopButton` from '@/components/shared/StopButton'
   - Add `const isStreaming = status === 'streaming';`
   - Add StopButton between error display and TypingIndicator:
     ```tsx
     {isStreaming && (
       <div className="flex justify-center py-2">
         <StopButton onClick={stop} />
       </div>
     )}
     ```

5. Track last message for retry (optional enhancement):
   - Add `const [lastUserMessage, setLastUserMessage] = useState('');`
   - In handleSubmit, before sendMessage: `setLastUserMessage(message);`
   - In handlePresetSelect: `setLastUserMessage(message);`

Keep all other page logic unchanged (scroll handling, message formatting, etc.).
  </action>
  <verify>
- Transport URL contains `marker=xml` (not `format=`)
- Uses environment variable for backend URL
- `stop` destructured from useChat
- toast import from sonner
- StopButton rendered conditionally on isStreaming
- useEffect cleanup calls stop()
  </verify>
  <done>Streamdown page wired to backend with stop button and error toast</done>
</task>

<task type="auto">
  <name>Task 2: Add skeleton loading for incomplete XML tags in StreamdownRenderer</name>
  <files>frontend/components/streamdown/StreamdownRenderer.tsx</files>
  <action>
Update StreamdownRenderer.tsx to show skeleton while XML tags are incomplete:

1. Import ComponentSkeleton:
   ```typescript
   import { ComponentSkeleton } from '@/components/shared/ComponentSkeleton';
   ```

2. Detect and hide incomplete XML tags in parseContent. Add these patterns BEFORE the complete tag matching:

   At the start of parseContent, detect incomplete tags and extract their type:
   ```typescript
   function parseContent(content: string, isStreaming: boolean): ContentSegment[] {
     const segments: ContentSegment[] = [];

     // Pattern for incomplete opening tags (streaming only)
     // Matches: <contactcard or <calendarevent followed by anything except closing >
     const incompleteOpeningPattern = /<(contactcard|calendarevent)(?![^>]*><\/\1>)/gi;

     // If streaming, check for incomplete tags at the end
     let contentToProcess = content;
     let pendingSkeleton: 'contact' | 'calendar' | null = null;

     if (isStreaming) {
       // Find incomplete tag at end of content
       const incompleteMatch = content.match(/<(contactcard|calendarevent)(?:(?!><\/\1>).)*$/i);
       if (incompleteMatch) {
         // Remove incomplete tag from processing
         contentToProcess = content.slice(0, incompleteMatch.index);
         pendingSkeleton = incompleteMatch[1].toLowerCase() === 'contactcard' ? 'contact' : 'calendar';
       }
     }

     // Continue with existing complete tag parsing using contentToProcess...
     const customTagPattern = /<(contactcard|calendarevent)([^>]*)><\/\1>/gi;
     // ... (rest of existing parsing logic, but use contentToProcess instead of content)
   ```

3. At the end of parseContent, add skeleton segment if pending:
   ```typescript
   // Add skeleton for incomplete tag at end
   if (pendingSkeleton) {
     segments.push({ type: 'skeleton', skeletonType: pendingSkeleton });
   }

   return segments;
   ```

4. Update ContentSegment type to include skeleton:
   ```typescript
   type ContentSegment =
     | { type: 'markdown'; content: string }
     | { type: 'contactcard'; props: ContactCardProps }
     | { type: 'calendarevent'; props: CalendarEventProps }
     | { type: 'skeleton'; skeletonType: 'contact' | 'calendar' };
   ```

5. Update parseContent function signature to accept isStreaming:
   ```typescript
   function parseContent(content: string, isStreaming: boolean): ContentSegment[]
   ```

6. Update useMemo call:
   ```typescript
   const segments = useMemo(() => parseContent(content, isStreaming), [content, isStreaming]);
   ```

7. Handle skeleton segment in render:
   ```tsx
   if (segment.type === 'skeleton') {
     return <ComponentSkeleton key={key} type={segment.skeletonType} />;
   }
   ```

8. Add fade-in class to completed components:
   ```tsx
   if (segment.type === 'contactcard') {
     return (
       <div key={key} className="component-fade-in">
         <ContactCard {...segment.props} />
       </div>
     );
   }

   if (segment.type === 'calendarevent') {
     return (
       <div key={key} className="component-fade-in">
         <CalendarEvent {...segment.props} />
       </div>
     );
   }
   ```

Key insight: During streaming, incomplete tags like `<contactcard name="...` appear at the end. We detect these, strip them from markdown processing, and render a skeleton instead.
  </action>
  <verify>
- ComponentSkeleton imported
- ContentSegment type includes skeleton
- parseContent accepts isStreaming parameter
- Incomplete XML tags replaced with skeleton during streaming
- Complete components wrapped in component-fade-in div
- No TypeScript errors: `npx tsc --noEmit`
  </verify>
  <done>StreamdownRenderer shows skeleton for incomplete XML tags, fades in complete components</done>
</task>

</tasks>

<verification>
- [ ] Page transport uses `marker=xml` with backend URL
- [ ] Stop button visible during streaming, calls stop()
- [ ] Error toast appears on network/server errors
- [ ] Stream aborted on page navigation (useEffect cleanup)
- [ ] Incomplete XML tags show skeleton (not raw tags)
- [ ] Complete components fade in smoothly
- [ ] `npx tsc --noEmit` passes
</verification>

<success_criteria>
1. Streamdown page connects to real backend with marker=xml (WIRE-02)
2. No incomplete XML tags visible during streaming (UX-02)
3. User can stop streaming via stop button
4. Errors show toast notification
5. Stream cleanup on navigation
</success_criteria>

<output>
After completion, create `.planning/phases/05-renderer-integration/05-03-SUMMARY.md`
</output>
